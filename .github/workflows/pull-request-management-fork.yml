# ------------------------------------------------------------------------------------
#  Pull Request Management for Forks Workflow
#
#  Purpose: Automate labeling, assignment, and welcoming of pull requests for forked PRs.
#
#  Configuration: All settings are loaded from .env.base and .env.custom files for
#  centralized management across all workflows.
#
#  Triggers: Pull request events (opened, reopened, ready for review, closed, synchronize)
#
#  Features:
#  - Automatic labeling based on branch prefix and PR title
#  - Default assignee management
#  - Welcome messages for first-time contributors
#  - PR size analysis and labeling
#  - Cache cleanup on PR close
#  - Branch deletion after merge
#
#  Maintainer: @mrz1836
#
#  SECURITY MODEL:
#  - Uses pull_request_target trigger for write permissions (required for labels/comments)
#  - CRITICAL: Only checks out BASE branch code, NEVER PR head (prevents malicious code execution)
#  - Fork detection uses full_name comparison for accuracy (not owner.login which fails for org members)
#  - All code execution happens from trusted base repository
#  - No secrets exposed to fork PRs (GITHUB_TOKEN only)
#
# ------------------------------------------------------------------------------------

name: PR Management (Forks)

# --------------------------------------------------------------------
# Trigger Configuration
# --------------------------------------------------------------------
on:
  pull_request_target:
    types: [opened, reopened, ready_for_review, closed, synchronize]

# Least privilege at the workflow level; jobs get bumps as needed
permissions:
  contents: read

# --------------------------------------------------------------------
# Concurrency Control
# --------------------------------------------------------------------
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number }}-fork
  cancel-in-progress: true

# --------------------------------------------------------------------
# Environment Variables
# --------------------------------------------------------------------
# Note: Configuration variables are loaded from .env.base and .env.custom files

jobs:
  # ------------------------------------------------------------
  # Load env from the BASE repo only (safe) for centralized config
  # ------------------------------------------------------------
  load-env:
    name: ðŸŒ Load Environment (Base Repo)
    runs-on: ubuntu-latest
    # No write perms here
    permissions:
      contents: read
    outputs:
      env-json: ${{ steps.load-env.outputs.env-json }}
    steps:
      - name: ðŸ“¥ Checkout base repo (sparse)
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          # CRITICAL SECURITY: Always checkout base branch (not PR head)
          # This prevents malicious code execution from fork PRs
          # pull_request_target runs with write permissions, so we MUST NOT
          # execute any code from the untrusted PR
          ref: ${{ github.base_ref }}
          fetch-depth: 1
          sparse-checkout: |
            .github/.env.base
            .github/.env.custom
            .github/actions/load-env

      - name: ðŸŒ Load environment variables
        id: load-env
        uses: ./.github/actions/load-env

  # ------------------------------------------------------------
  # Fork detector + labeller/commenter/assignee
  # ------------------------------------------------------------
  handle-fork:
    name: ðŸ·ï¸ Label/Assign/Comment (Fork PR)
    needs: [load-env]
    runs-on: ubuntu-latest
    # Only run for fork PRs (different repository)
    if: github.event.pull_request.head.repo.full_name != github.repository
    permissions:
      # We need to WRITE to PR for labels/comments/assignees
      pull-requests: write
      issues: write
      contents: read
    steps:
      - name: ðŸ”§ Extract config
        id: cfg
        env:
          ENV_JSON: ${{ needs.load-env.outputs.env-json }}
        run: |
          # pull minimal config, with sensible fallbacks
          DEFAULT_ASSIGNEE=$(echo "$ENV_JSON" | jq -r '.PR_MANAGEMENT_DEFAULT_ASSIGNEE // ""')
          SKIP_BOT_USERS=$(echo "$ENV_JSON" | jq -r '.PR_MANAGEMENT_SKIP_BOT_USERS // ""')
          FORK_LABEL=$(echo "$ENV_JSON" | jq -r '.PR_MANAGEMENT_FORK_LABEL // "from-fork"')
          TRIAGE_LABEL=$(echo "$ENV_JSON" | jq -r '.PR_MANAGEMENT_TRIAGE_LABEL // "needs-triage"')
          WELCOME_FORKS=$(echo "$ENV_JSON" | jq -r '.PR_MANAGEMENT_WELCOME_FORKS // "true"')

          echo "DEFAULT_ASSIGNEE=$DEFAULT_ASSIGNEE" >> "$GITHUB_ENV"
          echo "SKIP_BOT_USERS=$SKIP_BOT_USERS" >> "$GITHUB_ENV"
          echo "FORK_LABEL=$FORK_LABEL" >> "$GITHUB_ENV"
          echo "TRIAGE_LABEL=$TRIAGE_LABEL" >> "$GITHUB_ENV"
          echo "WELCOME_FORKS=$WELCOME_FORKS" >> "$GITHUB_ENV"

      - name: ðŸ·ï¸ Add fork + triage labels
        id: labels
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const prNumber = pr.number;
            const author = pr.user.login;

            // Skip bots if configured
            const skip = (process.env.SKIP_BOT_USERS || '')
              .split(',').map(s => s.trim()).filter(Boolean);
            if (skip.includes(author)) {
              core.info(`Skipping labels for bot user: ${author}`);
              return;
            }

            const ensureLabels = async (names) => {
              // create missing labels lazily (safe colors)
              for (const name of names) {
                try {
                  await github.rest.issues.getLabel({
                    owner: context.repo.owner, repo: context.repo.repo, name
                  });
                } catch (e) {
                  if (e.status === 404) {
                    await github.rest.issues.createLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      name,
                      color: name === process.env.TRIAGE_LABEL ? "d876e3" : "ededed",
                    });
                    core.info(`Created missing label: ${name}`);
                  } else {
                    throw e;
                  }
                }
              }
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: [process.env.FORK_LABEL, process.env.TRIAGE_LABEL]
              });
            };

            await ensureLabels([process.env.FORK_LABEL, process.env.TRIAGE_LABEL]);

      - name: ðŸ‘¤ Assign default assignee (optional)
        id: assign
        if: env.DEFAULT_ASSIGNEE != ''
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const author = pr.user.login;

            const skip = (process.env.SKIP_BOT_USERS || '')
              .split(',').map(s => s.trim()).filter(Boolean);
            if (skip.includes(author)) {
              core.info(`Skipping assignment for bot user: ${author}`);
              return;
            }

            if ((pr.assignees || []).length === 0) {
              await github.rest.issues.addAssignees({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                assignees: [process.env.DEFAULT_ASSIGNEE],
              });
              core.info(`Assigned to @${process.env.DEFAULT_ASSIGNEE}`);
            } else {
              core.info('PR already has assignees; skipping.');
            }

      - name: ðŸ’¬ Comment notice for fork PR
        id: comment
        if: env.WELCOME_FORKS == 'true' && github.event.action == 'opened'
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const author = pr.user.login;
            const repoName = context.repo.repo;
            const repoOwner = context.repo.owner;

            const body = `## ðŸ‘‹ Thanks, @${author}!

            This pull request comes from a **fork**. For security, our CI runs in a restricted mode (no repo secrets).
            A maintainer will triage this shortly and run any additional checks as needed.

            - ðŸ·ï¸ Labeled: \`${process.env.FORK_LABEL}\`, \`${process.env.TRIAGE_LABEL}\`
            - ðŸ‘€ Weâ€™ll review and follow up here if anything else is needed.

            Thanks for contributing to **${repoOwner}/${repoName}**! ðŸš€`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body
            });

  # ------------------------------------------------------------
  # Clean Runner Cache (on PR close)
  # ------------------------------------------------------------
  clean-cache:
    name: ðŸ§¹ Clean Runner Cache
    needs: [load-env]
    runs-on: ubuntu-latest
    permissions:
      actions: write # Required: Delete GitHub Actions caches for closed PRs
      contents: read # Read repository content for cache management
    if: github.event.action == 'closed'
    outputs:
      caches-cleaned: ${{ steps.clean.outputs.caches-cleaned }}

    steps:
      # --------------------------------------------------------------------
      # Extract configuration from env-json
      # --------------------------------------------------------------------
      - name: ðŸ”§ Extract configuration
        id: config
        env:
          ENV_JSON: ${{ needs.load-env.outputs.env-json }}
        run: |
          echo "ðŸ“‹ Extracting PR management configuration from environment..."

          # Extract all needed variables
          CLEAN_CACHE=$(echo "$ENV_JSON" | jq -r '.PR_MANAGEMENT_CLEAN_CACHE_ON_CLOSE // "true"')

          # Set as environment variables for all subsequent steps
          echo "CLEAN_CACHE=$CLEAN_CACHE" >> $GITHUB_ENV

          # Log configuration
          echo "ðŸ” Configuration loaded:"
          echo "  ðŸ§¹ Clean cache on close: $CLEAN_CACHE"

      # --------------------------------------------------------------------
      # Clean up caches associated with the PR
      # --------------------------------------------------------------------
      - name: ðŸ§¹ Cleanup caches
        id: clean
        if: env.CLEAN_CACHE == 'true'
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_HEAD_REF: ${{ github.event.pull_request.head.ref }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }}
        run: |
          echo "ðŸ§¹ Cleaning up caches for fork PR #$PR_NUMBER..."
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          # Fetch the list of cache keys for this PR
          echo "ðŸ“‹ Fetching cache list for PR #$PR_NUMBER..."

          # Get all caches and filter for this PR (checking multiple possible refs)
          allCaches=$(gh cache list --limit 100 --json id,key,ref)

          # Debug: Show what refs we're looking for
          echo "ðŸ” Looking for caches with refs:"
          echo "  - refs/pull/$PR_NUMBER/merge"
          echo "  - refs/pull/$PR_NUMBER/head"
          echo "  - refs/heads/$PR_HEAD_REF"

          # Filter caches that belong to this PR (multiple possible refs)
          cacheKeysForPR=$(echo "$allCaches" | jq -r --arg pr "$PR_NUMBER" --arg branch "$PR_HEAD_REF" \
            '.[] | select(
              .ref == "refs/pull/\($pr)/merge" or
              .ref == "refs/pull/\($pr)/head" or
              .ref == "refs/heads/\($branch)"
            ) | .id')

          # Count caches - handle empty results properly
          if [ -z "$cacheKeysForPR" ]; then
            cacheCount=0
          else
            cacheCount=$(echo "$cacheKeysForPR" | wc -l | tr -d ' ')
          fi

          if [ "$cacheCount" -eq "0" ]; then
            echo "â„¹ï¸ No caches found for this PR"
            echo "caches-cleaned=0" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "ðŸ—‘ï¸ Found $cacheCount cache(s) to clean"

          # Setting this to not fail the workflow while deleting cache keys
          set +e
          cleanedCount=0

          # Delete each cache
          for cacheKey in $cacheKeysForPR; do
            if gh cache delete "$cacheKey"; then
              echo "  âœ… Deleted cache: $cacheKey"
              ((cleanedCount++))
            else
              echo "  âš ï¸ Failed to delete cache: $cacheKey"
            fi
          done

          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "âœ… Cleaned $cleanedCount out of $cacheCount cache(s)"
          echo "caches-cleaned=$cleanedCount" >> $GITHUB_OUTPUT

  # ------------------------------------------------------------
  # Human-friendly run summary
  # ------------------------------------------------------------
  summary:
    name: ðŸ“Š Summary
    runs-on: ubuntu-latest
    if: always()
    needs: [load-env, handle-fork, clean-cache]
    steps:
      - name: ðŸ“„ Write summary
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_AUTHOR: ${{ github.event.pull_request.user.login }}
          PR_ACTION: ${{ github.event.action }}
        run: |
          echo "# ðŸ”§ Fork PR Management Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**PR:** #$PR_NUMBER â€” $PR_TITLE" >> $GITHUB_STEP_SUMMARY
          echo "**Author:** @$PR_AUTHOR" >> $GITHUB_STEP_SUMMARY
          echo "**Action:** $PR_ACTION" >> $GITHUB_STEP_SUMMARY
          echo "**Source:** Fork" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show cache cleanup results if PR was closed
          if [ "$PR_ACTION" = "closed" ]; then
            echo "## ðŸ§¹ Cleanup Actions" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Action | Result |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|--------|" >> $GITHUB_STEP_SUMMARY

            # Cache cleanup
            if [ "${{ needs.clean-cache.result }}" = "success" ]; then
              CACHES="${{ needs.clean-cache.outputs.caches-cleaned }}"
              echo "| ðŸ§¹ Cache Cleanup | $CACHES cache(s) cleaned |" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "**Security:** This workflow used **pull_request_target** and did **not** check out or execute the PR's code." >> $GITHUB_STEP_SUMMARY
